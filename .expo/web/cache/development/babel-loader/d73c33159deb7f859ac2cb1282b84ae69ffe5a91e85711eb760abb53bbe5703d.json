{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useOverlayPosition = useOverlayPosition;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _calculatePosition = require(\"./calculatePosition\");\nvar _react = require(\"react\");\nvar _useCloseOnScroll = require(\"./useCloseOnScroll\");\nvar _utils = require(\"@react-native-aria/utils\");\nvar visualViewport = typeof window !== 'undefined' && window.visualViewport;\nfunction useOverlayPosition(props) {\n  var direction = (0, _utils.isRTL)() ? 'rtl' : undefined;\n  var targetRef = props.targetRef,\n    overlayRef = props.overlayRef,\n    _props$scrollRef = props.scrollRef,\n    scrollRef = _props$scrollRef === void 0 ? overlayRef : _props$scrollRef,\n    _props$placement = props.placement,\n    placement = _props$placement === void 0 ? 'bottom' : _props$placement,\n    _props$containerPaddi = props.containerPadding,\n    containerPadding = _props$containerPaddi === void 0 ? 12 : _props$containerPaddi,\n    _props$shouldFlip = props.shouldFlip,\n    shouldFlip = _props$shouldFlip === void 0 ? true : _props$shouldFlip,\n    _props$boundaryElemen = props.boundaryElement,\n    boundaryElement = _props$boundaryElemen === void 0 ? typeof document !== 'undefined' ? document.body : null : _props$boundaryElemen,\n    _props$offset = props.offset,\n    offset = _props$offset === void 0 ? 0 : _props$offset,\n    _props$crossOffset = props.crossOffset,\n    crossOffset = _props$crossOffset === void 0 ? 0 : _props$crossOffset,\n    _props$shouldUpdatePo = props.shouldUpdatePosition,\n    shouldUpdatePosition = _props$shouldUpdatePo === void 0 ? true : _props$shouldUpdatePo,\n    _props$isOpen = props.isOpen,\n    isOpen = _props$isOpen === void 0 ? true : _props$isOpen,\n    _props$shouldOverlapW = props.shouldOverlapWithTrigger,\n    shouldOverlapWithTrigger = _props$shouldOverlapW === void 0 ? false : _props$shouldOverlapW,\n    onClose = props.onClose;\n  var _useState = (0, _react.useState)({\n      position: {},\n      arrowOffsetLeft: undefined,\n      arrowOffsetTop: undefined,\n      maxHeight: undefined,\n      placement: undefined\n    }),\n    _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n    position = _useState2[0],\n    setPosition = _useState2[1];\n  var deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction, shouldOverlapWithTrigger];\n  var updatePosition = (0, _react.useCallback)(function () {\n    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) {\n      return;\n    }\n    setPosition((0, _calculatePosition.calculatePosition)({\n      placement: translateRTL(placement, direction),\n      overlayNode: overlayRef.current,\n      targetNode: targetRef.current,\n      scrollNode: scrollRef.current,\n      padding: containerPadding,\n      shouldFlip: shouldFlip,\n      boundaryElement: boundaryElement,\n      offset: offset,\n      crossOffset: crossOffset,\n      shouldOverlapWithTrigger: shouldOverlapWithTrigger\n    }));\n  }, deps);\n  (0, _utils.useLayoutEffect)(updatePosition, deps);\n  useResize(updatePosition);\n  var isResizing = (0, _react.useRef)(false);\n  (0, _utils.useLayoutEffect)(function () {\n    var timeout;\n    var onResize = function onResize() {\n      isResizing.current = true;\n      clearTimeout(timeout);\n      timeout = setTimeout(function () {\n        isResizing.current = false;\n      }, 500);\n      updatePosition();\n    };\n    visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.addEventListener('resize', onResize);\n    return function () {\n      visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n  var close = (0, _react.useCallback)(function () {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n  (0, _useCloseOnScroll.useCloseOnScroll)({\n    triggerRef: targetRef,\n    isOpen: isOpen,\n    onClose: onClose ? close : undefined\n  });\n  return {\n    rendered: true,\n    overlayProps: {\n      style: Object.assign({\n        position: 'absolute',\n        zIndex: 100000\n      }, position.position, {\n        maxHeight: position.maxHeight\n      })\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop\n      }\n    },\n    updatePosition: updatePosition\n  };\n}\nfunction useResize(onResize) {\n  (0, _utils.useLayoutEffect)(function () {\n    window.addEventListener('resize', onResize, false);\n    return function () {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}","map":{"version":3,"names":["_calculatePosition","require","_react","_useCloseOnScroll","_utils","visualViewport","window","useOverlayPosition","props","direction","isRTL","undefined","targetRef","overlayRef","_props$scrollRef","scrollRef","_props$placement","placement","_props$containerPaddi","containerPadding","_props$shouldFlip","shouldFlip","_props$boundaryElemen","boundaryElement","document","body","_props$offset","offset","_props$crossOffset","crossOffset","_props$shouldUpdatePo","shouldUpdatePosition","_props$isOpen","isOpen","_props$shouldOverlapW","shouldOverlapWithTrigger","onClose","_useState","useState","position","arrowOffsetLeft","arrowOffsetTop","maxHeight","_useState2","_slicedToArray2","default","setPosition","deps","current","updatePosition","useCallback","calculatePosition","translateRTL","overlayNode","targetNode","scrollNode","padding","useLayoutEffect","useResize","isResizing","useRef","timeout","onResize","clearTimeout","setTimeout","addEventListener","removeEventListener","close","useCloseOnScroll","triggerRef","rendered","overlayProps","style","Object","assign","zIndex","arrowProps","left","top","replace"],"sources":["C:\\Users\\idriss.drame\\Projet\\ApmNews\\node_modules\\@react-native-aria\\overlays\\lib\\module\\web\\overlays\\src\\useOverlayPosition.ts"],"sourcesContent":["//@ts-nocheck\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { calculatePosition, PositionResult } from './calculatePosition';\nimport {\n  HTMLAttributes,\n  RefObject,\n  useCallback,\n  useRef,\n  useState,\n} from 'react';\nimport { Placement, PlacementAxis, PositionProps } from '@react-types/overlays';\nimport { useCloseOnScroll } from './useCloseOnScroll';\nimport { isRTL, useLayoutEffect } from '@react-native-aria/utils';\n\ninterface AriaPositionProps extends PositionProps {\n  /**\n   * Element that that serves as the positioning boundary.\n   * @default document.body\n   */\n  boundaryElement?: HTMLElement;\n  /**\n   * The ref for the element which the overlay positions itself with respect to.\n   */\n  targetRef: RefObject<HTMLElement>;\n  /**\n   * The ref for the overlay element.\n   */\n  overlayRef: RefObject<HTMLElement>;\n  /**\n   * A ref for the scrollable region within the overlay.\n   * @default overlayRef\n   */\n  scrollRef?: RefObject<HTMLElement>;\n  /**\n   * Whether the overlay should update its position automatically.\n   * @default true\n   */\n  shouldUpdatePosition?: boolean;\n  /** Handler that is called when the overlay should close. */\n  onClose?: () => void;\n  /** Determines whether the overlay should overlap with the trigger */\n  shouldOverlapWithTrigger?: boolean;\n}\n\ninterface PositionAria {\n  /** Props for the overlay container element. */\n  overlayProps: HTMLAttributes<Element>;\n  /** Props for the overlay tip arrow if any. */\n  arrowProps: HTMLAttributes<Element>;\n  /** Placement of the overlay with respect to the overlay trigger. */\n  placement: PlacementAxis;\n  /** Updates the position of the overlay. */\n  updatePosition(): void;\n}\n\n// @ts-ignore\nlet visualViewport = typeof window !== 'undefined' && window.visualViewport;\n\n/**\n * Handles positioning overlays like popovers and menus relative to a trigger\n * element, and updating the position when the window resizes.\n */\nexport function useOverlayPosition(props: AriaPositionProps): PositionAria {\n  const direction = isRTL() ? 'rtl' : undefined;\n  let {\n    targetRef,\n    overlayRef,\n    scrollRef = overlayRef,\n    placement = 'bottom' as Placement,\n    containerPadding = 12,\n    shouldFlip = true,\n    boundaryElement = typeof document !== 'undefined' ? document.body : null,\n    offset = 0,\n    crossOffset = 0,\n    shouldUpdatePosition = true,\n    isOpen = true,\n    shouldOverlapWithTrigger = false,\n    onClose,\n  } = props;\n  let [position, setPosition] = useState<PositionResult>({\n    position: {},\n    arrowOffsetLeft: undefined,\n    arrowOffsetTop: undefined,\n    maxHeight: undefined,\n    placement: undefined,\n  });\n\n  let deps = [\n    shouldUpdatePosition,\n    placement,\n    overlayRef.current,\n    targetRef.current,\n    scrollRef.current,\n    containerPadding,\n    shouldFlip,\n    boundaryElement,\n    offset,\n    crossOffset,\n    isOpen,\n    direction,\n    shouldOverlapWithTrigger,\n  ];\n\n  let updatePosition = useCallback(() => {\n    if (\n      shouldUpdatePosition === false ||\n      !isOpen ||\n      !overlayRef.current ||\n      !targetRef.current ||\n      !scrollRef.current ||\n      !boundaryElement\n    ) {\n      return;\n    }\n\n    setPosition(\n      calculatePosition({\n        placement: translateRTL(placement, direction),\n        overlayNode: overlayRef.current,\n        targetNode: targetRef.current,\n        scrollNode: scrollRef.current,\n        padding: containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        shouldOverlapWithTrigger,\n      })\n    );\n  }, deps);\n\n  // Update position when anything changes\n  useLayoutEffect(updatePosition, deps);\n\n  // Update position on window resize\n  useResize(updatePosition);\n\n  // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n  // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n  let isResizing = useRef(false);\n  useLayoutEffect(() => {\n    let timeout: NodeJS.Timeout;\n    let onResize = () => {\n      isResizing.current = true;\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        isResizing.current = false;\n      }, 500);\n\n      updatePosition();\n    };\n\n    visualViewport?.addEventListener('resize', onResize);\n\n    return () => {\n      visualViewport?.removeEventListener('resize', onResize);\n    };\n  }, [updatePosition]);\n\n  let close = useCallback(() => {\n    if (!isResizing.current) {\n      onClose();\n    }\n  }, [onClose, isResizing]);\n\n  // When scrolling a parent scrollable region of the trigger (other than the body),\n  // we hide the popover. Otherwise, its position would be incorrect.\n  useCloseOnScroll({\n    triggerRef: targetRef,\n    isOpen,\n    onClose: onClose ? close : undefined,\n  });\n\n  // useLayoutEffect(() => {\n  //   const mutationObserver = new MutationObserver((mutations) => {\n  //     updatePosition();\n  //     mutations.forEach((mutation) => {\n  //       // if (mutation.attributeName === 'style') {\n  //       //   const transform = mutation.target.style.transform;\n  //       //   if (transform) {\n  //       //     const match = transform.match(/scale\\((.+)\\)/);\n  //       //     if (match) {\n  //       //       const scale = parseFloat(match[1]);\n  //       //       console.log(`Scale: ${scale}`);\n  //       //       // updatePosition();\n  //       //     }\n  //       //   }\n  //       // }\n  //     });\n  //   });\n\n  //   mutationObserver.observe(overlayRef?.current, { attributes: true });\n\n  //   return () => mutationObserver.disconnect();\n  // }, [overlayRef, updatePosition]);\n\n  return {\n    rendered: true,\n    overlayProps: {\n      style: {\n        position: 'absolute',\n        zIndex: 100000, // should match the z-index in ModalTrigger\n        ...position.position,\n        maxHeight: position.maxHeight,\n      },\n    },\n    placement: position.placement,\n    arrowProps: {\n      style: {\n        left: position.arrowOffsetLeft,\n        top: position.arrowOffsetTop,\n      },\n    },\n    updatePosition,\n  };\n}\n\nfunction useResize(onResize) {\n  useLayoutEffect(() => {\n    window.addEventListener('resize', onResize, false);\n    return () => {\n      window.removeEventListener('resize', onResize, false);\n    };\n  }, [onResize]);\n}\n\nfunction translateRTL(position, direction) {\n  if (direction === 'rtl') {\n    return position.replace('start', 'right').replace('end', 'left');\n  }\n  return position.replace('start', 'left').replace('end', 'right');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}